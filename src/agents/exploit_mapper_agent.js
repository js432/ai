// ExploitMapper Agent - Discovers attack chains using abstract modeling

import { BaseAgent } from './base_agent.js';

export class ExploitMapperAgent extends BaseAgent {
  constructor(config = {}) {
    super({
      name: 'ExploitMapperAgent',
      description: 'Discovers attack chains using abstract modeling',
      ...config
    });
    
    this.vulnerabilityDatabase = [];
    this.attackChains = [];
  }
  
  /**
   * Processes a security analysis prompt
   * @param {string} prompt - The prompt to process
   * @param {Object} options - Processing options
   * @returns {Promise<Object>} - Analysis result
   */
  async _processPrompt(prompt, options = {}) {
    console.log('ExploitMapperAgent processing prompt:', prompt);
    
    // Create a system prompt for the security analysis
    const systemPrompt = `
You are the ExploitMapperAgent in the Hermes-X Core system.
Your role is to analyze systems for security vulnerabilities and map potential attack chains.

TASK: ${prompt}

Please conduct a thorough security analysis:
1. Identify potential vulnerabilities and weaknesses
2. Categorize each vulnerability (e.g., XSS, CSRF, SQLi, etc.)
3. Assess the impact and exploitability of each vulnerability
4. Map possible attack chains that combine multiple vulnerabilities
5. Suggest mitigation strategies for each vulnerability

Your analysis should be detailed, technical, and actionable.
`;

    try {
      // Call the API for security analysis
      const response = await this.callAPI(systemPrompt, {
        temperature: 0.4,
        max_tokens: 2000,
        ...options
      });
      
      // Parse the response to extract vulnerabilities and attack chains
      const analysis = this._parseSecurityAnalysis(response.text);
      
      // Update the vulnerability database
      this._updateVulnerabilityDatabase(analysis.vulnerabilities);
      
      // Update attack chains
      this._updateAttackChains(analysis.attackChains);
      
      // Save the analysis to memory
      await this.saveToMemory({
        type: 'security_analysis',
        data: {
          prompt,
          analysis,
          timestamp: new Date().toISOString()
        }
      });
      
      return {
        analysis,
        raw: response.text
      };
    } catch (error) {
      console.error('Error in ExploitMapperAgent:', error);
      throw error;
    }
  }
  
  /**
   * Parses security analysis from the API response
   * @param {string} response - API response text
   * @returns {Object} - Structured security analysis
   */
  _parseSecurityAnalysis(response) {
    // Extract vulnerabilities
    const vulnerabilities = this._extractVulnerabilities(response);
    
    // Extract attack chains
    const attackChains = this._extractAttackChains(response);
    
    // Extract mitigation strategies
    const mitigations = this._extractMitigations(response);
    
    return {
      vulnerabilities,
      attackChains,
      mitigations,
      summary: this._extractSummary(response)
    };
  }
  
  /**
   * Extracts vulnerabilities from text
   * @param {string} text - Text containing vulnerabilities
   * @returns {Array<Object>} - Extracted vulnerabilities
   */
  _extractVulnerabilities(text) {
    const vulnerabilities = [];
    
    // Look for vulnerability sections
    const vulnRegex = /(?:Vulnerability|Weakness)\s*\d*\s*:\s*([^\n]+)(?:\n|$)([\s\S]*?)(?=(?:Vulnerability|Weakness|Attack Chain|Mitigation)\s*\d*\s*:|$)/gi;
    
    let match;
    while ((match = vulnRegex.exec(text)) !== null) {
      const name = match[1].trim();
      const details = match[2].trim();
      
      // Extract category
      const categoryMatch = details.match(/Category\s*:\s*([^\n]+)/i);
      const category = categoryMatch ? categoryMatch[1].trim() : this._inferCategory(name);
      
      // Extract severity
      const severityMatch = details.match(/(?:Severity|Impact)\s*:\s*([^\n]+)/i);
      const severity = severityMatch ? severityMatch[1].trim() : 'Medium';
      
      // Extract exploitability
      const exploitabilityMatch = details.match(/Exploitability\s*:\s*([^\n]+)/i);
      const exploitability = exploitabilityMatch ? exploitabilityMatch[1].trim() : 'Medium';
      
      vulnerabilities.push({
        name,
        category,
        severity,
        exploitability,
        details: details.replace(/(?:Category|Severity|Impact|Exploitability)\s*:\s*[^\n]+\n?/gi, '').trim()
      });
    }
    
    return vulnerabilities;
  }
  
  /**
   * Infers a vulnerability category from its name
   * @param {string} name - Vulnerability name
   * @returns {string} - Inferred category
   */
  _inferCategory(name) {
    const name_lower = name.toLowerCase();
    
    if (name_lower.includes('xss') || name_lower.includes('cross-site script')) {
      return 'Cross-Site Scripting (XSS)';
    } else if (name_lower.includes('sql') || name_lower.includes('injection')) {
      return 'Injection';
    } else if (name_lower.includes('csrf') || name_lower.includes('cross-site request')) {
      return 'Cross-Site Request Forgery (CSRF)';
    } else if (name_lower.includes('auth') || name_lower.includes('session')) {
      return 'Authentication';
    } else if (name_lower.includes('config') || name_lower.includes('setup')) {
      return 'Security Misconfiguration';
    } else if (name_lower.includes('exposure') || name_lower.includes('disclosure')) {
      return 'Sensitive Data Exposure';
    } else if (name_lower.includes('access') || name_lower.includes('permission')) {
      return 'Broken Access Control';
    } else if (name_lower.includes('dos') || name_lower.includes('denial')) {
      return 'Denial of Service';
    } else {
      return 'Other';
    }
  }
  
  /**
   * Extracts attack chains from text
   * @param {string} text - Text containing attack chains
   * @returns {Array<Object>} - Extracted attack chains
   */
  _extractAttackChains(text) {
    const attackChains = [];
    
    // Look for attack chain sections
    const chainRegex = /Attack Chain\s*\d*\s*:\s*([^\n]+)(?:\n|$)([\s\S]*?)(?=(?:Vulnerability|Weakness|Attack Chain|Mitigation)\s*\d*\s*:|$)/gi;
    
    let match;
    while ((match = chainRegex.exec(text)) !== null) {
      const name = match[1].trim();
      const details = match[2].trim();
      
      // Extract steps
      const steps = [];
      const stepRegex = /(?:Step|Phase)\s*(\d+)\s*:\s*([^\n]+)(?:\n|$)([\s\S]*?)(?=(?:Step|Phase)\s*\d+\s*:|$)/gi;
      
      let stepMatch;
      while ((stepMatch = stepRegex.exec(details)) !== null) {
        const stepNumber = parseInt(stepMatch[1], 10);
        const stepName = stepMatch[2].trim();
        const stepDetails = stepMatch[3].trim();
        
        steps.push({
          number: stepNumber,
          name: stepName,
          details: stepDetails
        });
      }
      
      // If no steps were found, try to extract them from bullet points
      if (steps.length === 0) {
        const bulletSteps = details.split(/\n\s*[\-\*]\s*/).filter(s => s.trim());
        
        bulletSteps.forEach((step, index) => {
          steps.push({
            number: index + 1,
            name: step.split(':')[0]?.trim() || `Step ${index + 1}`,
            details: step.split(':').slice(1).join(':').trim() || step.trim()
          });
        });
      }
      
      attackChains.push({
        name,
        steps: steps.length > 0 ? steps : [{
          number: 1,
          name: 'Attack Chain',
          details
        }],
        impact: this._extractImpact(details)
      });
    }
    
    return attackChains;
  }
  
  /**
   * Extracts impact information from text
   * @param {string} text - Text containing impact information
   * @returns {string} - Extracted impact
   */
  _extractImpact(text) {
    const impactMatch = text.match(/Impact\s*:\s*([^\n]+)/i);
    return impactMatch ? impactMatch[1].trim() : '';
  }
  
  /**
   * Extracts mitigation strategies from text
   * @param {string} text - Text containing mitigations
   * @returns {Array<Object>} - Extracted mitigations
   */
  _extractMitigations(text) {
    const mitigations = [];
    
    // Look for mitigation sections
    const mitigationRegex = /Mitigation\s*\d*\s*(?:for\s*([^\n:]+)\s*)?:\s*([^\n]+)(?:\n|$)([\s\S]*?)(?=(?:Vulnerability|Weakness|Attack Chain|Mitigation)\s*\d*\s*:|$)/gi;
    
    let match;
    while ((match = mitigationRegex.exec(text)) !== null) {
      const target = match[1]?.trim() || '';
      const name = match[2].trim();
      const details = match[3].trim();
      
      mitigations.push({
        target,
        name,
        details
      });
    }
    
    // If no structured mitigations were found, look for a mitigation section
    if (mitigations.length === 0) {
      const mitigationSection = text.match(/(?:Mitigations?|Recommendations?|Remediation)(?:\s*Strategies?)?:([\s\S]*?)(?=\n\s*\n|$)/i);
      
      if (mitigationSection) {
        const mitigationText = mitigationSection[1].trim();
        const bulletMitigations = mitigationText.split(/\n\s*[\-\*]\s*/).filter(s => s.trim());
        
        bulletMitigations.forEach((mitigation) => {
          const parts = mitigation.split(':');
          
          if (parts.length > 1) {
            mitigations.push({
              target: '',
              name: parts[0].trim(),
              details: parts.slice(1).join(':').trim()
            });
          } else {
            mitigations.push({
              target: '',
              name: mitigation.substring(0, 50) + (mitigation.length > 50 ? '...' : ''),
              details: mitigation
            });
          }
        });
      }
    }
    
    return mitigations;
  }
  
  /**
   * Extracts a summary from the analysis
   * @param {string} text - Analysis text
   * @returns {string} - Extracted summary
   */
  _extractSummary(text) {
    // Look for a summary section
    const summaryMatch = text.match(/(?:Summary|Overview|Conclusion):([\s\S]*?)(?=\n\s*\n|$)/i);
    
    if (summaryMatch) {
      return summaryMatch[1].trim();
    }
    
    // If no summary section, use the first paragraph
    const firstParagraph = text.split(/\n\s*\n/)[0];
    return firstParagraph.trim();
  }
  
  /**
   * Updates the vulnerability database
   * @param {Array<Object>} vulnerabilities - New vulnerabilities
   */
  _updateVulnerabilityDatabase(vulnerabilities) {
    for (const vulnerability of vulnerabilities) {
      // Check if the vulnerability already exists
      const existingIndex = this.vulnerabilityDatabase.findIndex(v => 
        v.name.toLowerCase() === vulnerability.name.toLowerCase() ||
        v.details.toLowerCase() === vulnerability.details.toLowerCase()
      );
      
      if (existingIndex >= 0) {
        // Update existing vulnerability
        this.vulnerabilityDatabase[existingIndex] = {
          ...this.vulnerabilityDatabase[existingIndex],
          ...vulnerability,
          lastUpdated: new Date().toISOString()
        };
      } else {
        // Add new vulnerability
        this.vulnerabilityDatabase.push({
          ...vulnerability,
          id: `vuln-${Date.now()}-${this.vulnerabilityDatabase.length}`,
          discovered: new Date().toISOString(),
          lastUpdated: new Date().toISOString()
        });
      }
    }
  }
  
  /**
   * Updates the attack chains
   * @param {Array<Object>} attackChains - New attack chains
   */
  _updateAttackChains(attackChains) {
    for (const chain of attackChains) {
      // Check if the attack chain already exists
      const existingIndex = this.attackChains.findIndex(c => 
        c.name.toLowerCase() === chain.name.toLowerCase()
      );
      
      if (existingIndex >= 0) {
        // Update existing attack chain
        this.attackChains[existingIndex] = {
          ...this.attackChains[existingIndex],
          ...chain,
          lastUpdated: new Date().toISOString()
        };
      } else {
        // Add new attack chain
        this.attackChains.push({
          ...chain,
          id: `chain-${Date.now()}-${this.attackChains.length}`,
          discovered: new Date().toISOString(),
          lastUpdated: new Date().toISOString()
        });
      }
    }
  }
  
  /**
   * Gets the vulnerability database
   * @returns {Array<Object>} - Vulnerability database
   */
  getVulnerabilityDatabase() {
    return this.vulnerabilityDatabase;
  }
  
  /**
   * Gets the attack chains
   * @returns {Array<Object>} - Attack chains
   */
  getAttackChains() {
    return this.attackChains;
  }
  
  /**
   * Analyzes a specific vulnerability
   * @param {string} vulnerabilityName - Vulnerability name
   * @returns {Promise<Object>} - Detailed analysis
   */
  async analyzeVulnerability(vulnerabilityName) {
    // Find the vulnerability in the database
    const vulnerability = this.vulnerabilityDatabase.find(v => 
      v.name.toLowerCase() === vulnerabilityName.toLowerCase()
    );
    
    if (!vulnerability) {
      throw new Error(`Vulnerability not found: ${vulnerabilityName}`);
    }
    
    // Create a prompt for detailed analysis
    const prompt = `
Perform a detailed analysis of the following vulnerability:

NAME: ${vulnerability.name}
CATEGORY: ${vulnerability.category}
DETAILS: ${vulnerability.details}

Please provide:
1. A technical explanation of how this vulnerability works
2. Common exploitation techniques
3. Potential impact if exploited
4. Detailed mitigation strategies
5. Code examples of vulnerable and secure implementations
`;

    // Process the prompt
    const result = await this.process(prompt);
    
    return {
      vulnerability,
      analysis: result.analysis
    };
  }
}